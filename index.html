<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Games WAM | Catalog</title>
	<meta name="description" content="Browse the latest items in a clean, fast catalog layout.">
	<!-- Favicon -->
	<link rel="icon" href="/logo-icon.svg" type="image/svg+xml">
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-GN1K1JFT39"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'G-GN1K1JFT39');
	</script>

	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

	<style>
		:root{
			--bg:#1a202c;
			--surface:#2d3748;
			--surface-2:#4a5568;
			--surface-3:#718096;
			--text:#ffffff;
			--muted:#a0aec0;
			--border:#4a5568;
			--accent-1:#00b4d8; /* cyan/teal */
			--accent-2:#0096c7; /* darker teal */
			--accent-3:#ff6b35; /* orange */
			--accent-4:#e53e3e; /* red */
			--ring:rgba(0,180,216,.35);
			--badge:#00b4d8;
			--gradient-1:linear-gradient(135deg, #00b4d8, #0096c7);
			--gradient-2:linear-gradient(135deg, #ff6b35, #e53e3e);
			--gradient-3:radial-gradient(120% 120% at 0% 0%, rgba(0,180,216,.2) 0%, transparent 50%);
			--radius:12px;
		}

		*{margin:0;padding:0;box-sizing:border-box}
		html,body{height:100%}
		body{
			font-family:-apple-system,BlinkMacSystemFont,"Inter","SF Pro Display","SF Pro Text",sans-serif;
			background:var(--bg);
			color:var(--text);
			-webkit-font-smoothing:antialiased;
			-moz-osx-font-smoothing:grayscale;
			line-height:1.5;
			overflow-x:hidden;
		}

		/* Top bar */
		.topbar{
			background:
				linear-gradient(180deg, rgba(0,180,216,0.15), transparent 60%),
				var(--surface);
			border-bottom:1px solid var(--border);
			backdrop-filter:blur(10px);
		}
		.container{
			max-width:1200px;
			margin:0 auto;
			padding:0 16px;
		}
		.nav{
			height:60px;
			display:flex;
			align-items:center;
			justify-content:space-between;
			gap:10px;
		}
		.brand{
			display:flex;
			align-items:center;
			gap:10px;
			text-decoration:none;
			color:var(--text);
			font-weight:800;
			letter-spacing:-0.02em;
		}
		.brand img{
			height:40px;
			width:auto;
		}

		/* Search */
		.search{
			flex:1;
			display:grid;
			grid-template-columns:1fr 110px;
			gap:8px;
			max-width:560px;
			margin:0 0 0 12px;
			width:100%;
			min-width:0;
		}
		.search-input{
			background:rgba(0,180,216,0.1);
			border:1px solid rgba(0,180,216,0.3);
			height:42px;
			border-radius:12px;
			padding:0 14px;
			color:#ffffff;
			outline:none;
			transition:border-color .2s ease, box-shadow .2s ease, background .2s ease;
			min-width:0;
			font-size:14px;
			backdrop-filter:blur(10px);
		}
		.search-input::placeholder{
			color:rgba(255,255,255,0.6);
		}
		.search-input:focus{
			border-color:var(--accent-1);
			box-shadow:0 0 0 3px rgba(0,180,216,.2);
			background:rgba(0,180,216,0.15);
		}
		.search-btn{
			height:42px;
			border:none;cursor:pointer;
			border-radius:12px;
			color:#fff;font-weight:700;letter-spacing:.01em;
			background:var(--gradient-1);
			box-shadow:0 8px 22px rgba(0,180,216,.4);
			transition:transform .15s ease, box-shadow .15s ease;
		}
		.search-btn:hover{
			transform:translateY(-1px);
			box-shadow:0 12px 28px rgba(0,180,216,.5);
		}
		.search-btn:active{
			transform:translateY(0);
		}

		/* Hero slider */
		.hero{
			background:var(--surface);
			border-bottom:1px solid var(--border);
		}
		.hero-wrap{padding:12px 0 16px}
		.slider{
			position:relative;overflow:hidden;border-radius:16px;border:1px solid var(--border);
			background:var(--surface-2);isolation:isolate;
		}
		.slider::before{
			content:"";position:absolute;inset:-2px;
			background:conic-gradient(from 180deg at 50% 50%, rgba(0,180,216,.4), rgba(0,150,199,.4), rgba(255,107,53,.4), rgba(0,180,216,.4));
			filter:blur(20px);z-index:-1;opacity:.6;animation:spin 15s linear infinite;
		}
		@keyframes spin { to { transform: rotate(360deg) } }

		.slides{
			display:flex;will-change:transform;
			transition:transform 420ms cubic-bezier(.22,.61,.36,1);
			touch-action:pan-y;
		}
		.slide{
			min-width:100%;
			aspect-ratio:21/9;
			background:
				var(--gradient-3),
				radial-gradient(120% 120% at 100% 0%, rgba(255,107,53,.15) 0%, transparent 52%),
				linear-gradient(135deg, #2d3748, #4a5568);
			position:relative;overflow:hidden;
			background-size:cover;background-position:center;
		}
		.slide::after{
			content:"";position:absolute;inset:0;
			background:linear-gradient(to top, rgba(26,32,44,.6), rgba(26,32,44,0) 60%);
		}
		.slider-nav{
			position:absolute;inset:0;display:flex;align-items:center;justify-content:space-between;
			padding:0 6px;pointer-events:none;
		}
		.nav-btn{
			pointer-events:auto;width:36px;height:36px;border-radius:999px;border:1px solid var(--border);
			background:rgba(45,55,72,.8);color:#fff;display:flex;align-items:center;justify-content:center;
			cursor:pointer;backdrop-filter:blur(8px);
			transition:transform .15s ease, background .2s ease, border-color .2s ease;
		}
		.nav-btn:hover{
			border-color:var(--accent-1);
			background:rgba(0,180,216,.2);
		}
		.nav-btn:active{transform:scale(.96)}
		.dots{
			position:absolute;left:0;right:0;bottom:10px;
			display:flex;gap:6px;justify-content:center;align-items:center;
		}
		.dot{
			width:8px;height:8px;border-radius:999px;background:#718096;border:1px solid var(--border);
			transition:width .2s ease, background .2s ease;cursor:pointer;
		}
		.dot.active{width:20px;background:var(--gradient-1);border-color:var(--accent-1)}

		/* Page */
		.page{padding:16px 0 36px}
		.section{display:flex;align-items:center;justify-content:space-between;margin:6px 0 14px}
		.section-title{font-size:20px;font-weight:800;letter-spacing:-0.02em;color:#fff}
		.section-sub{color:var(--muted);font-size:13px}

		/* Grid */
		.grid{
			display:grid;
			grid-template-columns:repeat(auto-fill,minmax(156px,1fr));
			gap:12px;
		}
		.card{
			background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);
			overflow:hidden;position:relative;transition:transform .18s ease, box-shadow .18s ease, border-color .18s ease;
			will-change:transform;
		}
		.card:hover{
			transform:translateY(-3px);
			border-color:var(--accent-1);
			box-shadow:
				0 10px 28px rgba(0,0,0,.4), 
				0 0 0 1px rgba(0,180,216,.3) inset,
				0 0 20px rgba(0,180,216,.2);
		}
		.poster{
			height:210px;
			background:
				var(--gradient-3),
				radial-gradient(120% 120% at 100% 0%, rgba(255,107,53,.12) 0%, transparent 52%),
				linear-gradient(135deg, #2d3748, #4a5568);
			border-bottom:1px solid var(--border);
			position:relative;
			background-size:cover;
			background-position:center;
		}
		.badge{
			position:absolute;top:10px;left:10px;
			background:var(--gradient-2);
			color:#fff;font-weight:800;font-size:11px;padding:6px 8px;border-radius:8px;
			letter-spacing:.04em;opacity:0;
			box-shadow:0 4px 12px rgba(255,107,53,.4);
		}
		.overlay{
			position:absolute;inset:0;
			background:linear-gradient(to top, rgba(26,32,44,.6), rgba(26,32,44,0) 60%);
			opacity:0;transition:opacity .18s ease;
		}
		.card:hover .overlay{opacity:1}
		.meta{padding:10px 12px 12px}
		.title{height:16px;overflow:hidden;color:var(--text)}
		.tags,.actions{display:none}

		/* Pager */
		.pager{margin-top:18px;display:flex;justify-content:center;gap:8px}
		.page-btn{
			background:var(--surface);color:var(--muted);border:1px solid var(--border);
			height:40px;min-width:40px;border-radius:10px;padding:0 12px;cursor:pointer;
			transition:all .18s ease;
		}
		.page-btn:hover{
			border-color:var(--accent-1);
			color:#f9fafb;
			background:rgba(0,180,216,.1);
		}
		.page-btn.active{
			color:#fff;border-color:transparent;
			background:var(--gradient-1);
			box-shadow:0 4px 12px rgba(0,180,216,.3);
		}

		/* Footer */
		.footer{
			margin-top:28px;background:var(--surface);border-top:1px solid var(--border);
			padding:22px 0 26px;color:var(--muted);text-align:center;
		}
		.foot-links{display:flex;justify-content:center;gap:16px;flex-wrap:wrap;margin-bottom:10px}
		.foot-links a{color:#d1d5db;text-decoration:none;font-size:13px;transition:color .2s ease}
		.foot-links a:hover{color:var(--accent-1)}

		/* VPN Block */
		.vpn-block{
			position:fixed;inset:0;
			background:linear-gradient(135deg,#7c3aed,#a855f7);
			color:#fff;display:none;align-items:center;justify-content:center;z-index:99999;text-align:center;padding:20px;
		}
		.vpn-block-content{max-width:600px}
		.vpn-block h1{font-size:2.1rem;margin-bottom:12px;font-weight:800}
		.vpn-block p{opacity:.95}

		/* Popup */
		.popup-overlay{
			position:fixed;inset:0;background:rgba(26,32,44,.9);backdrop-filter:blur(12px);
			z-index:10000;display:none;align-items:center;justify-content:center;
		}
		.popup-overlay.show{display:flex}
		.popup-content{
			background:#fff;border-radius:20px;width:600px;max-width:92vw;height:520px;max-height:85vh;
			position:relative;overflow:hidden;
			box-shadow:0 25px 50px rgba(0,0,0,.6), 0 0 0 1px rgba(0,180,216,.3);
		}
		.popup-close{
			position:absolute;top:12px;right:12px;width:32px;height:32px;border-radius:50%;
			border:none;background:rgba(0,0,0,.08);cursor:pointer;color:#333;font-size:18px;
		}
		.popup-iframe{width:100%;height:100%;border:none}

		/* Motion preferences */
		@media (prefers-reduced-motion: reduce){
			.slides{transition:none}
			.slider::before{animation:none}
			.card:hover{transform:none}
		}

		/* Responsive */
		@media (max-width:768px){
			.container{padding:0 14px}
			.nav{
				gap:8px;
				flex-wrap:wrap;
				min-height:110px;
				align-items:flex-start;
				padding:12px 0;
			}
			.brand{
				flex:0 0 auto;
				margin-top:4px;
			}
			.brand img{
				height:32px;
			}
			.hero-wrap{padding:10px 0 12px}
			.search{
				flex:1 0 100%;
				order:2;
				margin:16px 0 0 0;
				max-width:none;
				grid-template-columns:1fr 75px;
			}
			.search-input{height:40px}
			.search-btn{height:40px;font-size:13px;padding:0 8px}
			.grid{grid-template-columns:repeat(3,1fr);gap:10px}
			.poster{height:160px}
			.section{margin:4px 0 10px}
			.section-title{font-size:18px}
			.card:hover{transform:translateY(-2px)}
		}

		@media (max-width:520px){
			.container{padding:0 12px}
			.nav{
				min-height:120px;
				padding:12px 0 8px 0;
			}
			.search{
				grid-template-columns:1fr;
				gap:8px;
				margin:18px 0 0 0;
			}
			.search-btn{
				width:100%;
				font-size:16px;
			}
			.grid{grid-template-columns:repeat(2,1fr);gap:10px}
			.poster{height:150px}
			.brand{gap:8px}
			.brand img{
				height:28px;
			}
		}
	</style>
</head>
<body>

	<!-- VPN Block Screen -->
	<div class="vpn-block" id="vpnBlock">
		<div class="vpn-block-content">
			<h1>Access Blocked</h1>
			<p>VPN or Proxy connections are not allowed on this site.</p>
			<p>Please disable your VPN/Proxy and refresh the page to continue.</p>
		</div>
	</div>

	<!-- Topbar -->
	<header class="topbar">
		<div class="container">
			<div class="nav">
				<a class="brand" href="#">
					<img src="/logo-horizontal.svg" alt="Games WAM" height="40">
				</a>
				<div class="search">
					<input id="mainSearch" class="search-input" type="text" placeholder="Search games..." />
					<button class="search-btn" onclick="performSearch()">Search</button>
				</div>
			</div>
		</div>
	</header>

	<!-- Hero slider -->
	<section class="hero">
		<div class="container hero-wrap">
			<div class="slider" id="slider">
				<div class="slides" id="slides">
					<div class="slide" data-bg=""></div>
					<div class="slide" data-bg=""></div>
					<div class="slide" data-bg=""></div>
				</div>
				<div class="slider-nav">
					<button class="nav-btn" id="prev" aria-label="Previous">‹</button>
					<button class="nav-btn" id="next" aria-label="Next">›</button>
				</div>
				<div class="dots" id="dots"></div>
			</div>
		</div>
	</section>

	<!-- Page -->
	<main class="page">
		<div class="container">
			<div class="section">
				<div class="section-title">Latest Updates</div>
				<div class="section-sub">Fresh content with a clean, fast layout</div>
			</div>

			<div class="grid" id="grid"></div>

			<div class="pager" aria-label="Pagination">
				<button class="page-btn">«</button>
				<button class="page-btn active">1</button>
				<button class="page-btn">2</button>
				<button class="page-btn">3</button>
				<button class="page-btn">»</button>
			</div>
		</div>
	</main>

	<!-- Content Locker Popup -->
	<div class="popup-overlay" id="contentLockerPopup">
		<div class="popup-content">
			<button class="popup-close" onclick="closeContentLocker()">×</button>
			<iframe id="contentLockerFrame" class="popup-iframe" src=""></iframe>
		</div>
	</div>

	<!-- Footer -->
	<footer class="footer">
		<div class="container">
			<div class="foot-links">
				<a href="#" onclick="showInfo('contact')">Contact</a>
				<a href="#" onclick="showInfo('privacy')">Privacy</a>
				<a href="#" onclick="showInfo('terms')">Terms</a>
				<a href="#" onclick="showInfo('about')">About</a>
			</div>
			<div>&copy; 2024 Games WAM. All rights reserved.</div>
		</div>
	</footer>

	<script>
		/* Enhanced VPN Detection - Cross-browser compatible */
		(function() {
			'use strict';
			
			const VPN_CONFIG = {
				'detectionMethods': [
					'webrtc', 'timezone', 'dns', 'api', 'headers', 'fingerprint'
				],
				'thresholds': { 
					'minScore': 0.4,
					'minDetections': 2 
				},
				'timeout': 15000
			};

			let detectionState = {
				blocked: false,
				score: 0,
				detections: 0,
				results: {}
			};

			// Enhanced WebRTC leak detection
			async function detectWebRTCLeak() {
				return new Promise((resolve) => {
					try {
						const timeout = setTimeout(() => {
							cleanup();
							resolve({ detected: false, confidence: 0 });
						}, 5000);

						let detectedIPs = new Set();
						const pc = new RTCPeerConnection({
							iceServers: [
								{ urls: 'stun:stun.l.google.com:19302' },
								{ urls: 'stun:stun1.l.google.com:19302' }
							]
						});

						function cleanup() {
							try {
								pc.close();
							} catch(e) {}
							clearTimeout(timeout);
						}

						pc.onicecandidate = function(event) {
							if (event.candidate) {
								const match = event.candidate.candidate.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/);
								if (match) {
									const ip = match[1];
									// Exclude local/private IPs
									if (!ip.startsWith('127.') && 
										!ip.startsWith('192.168.') && 
										!ip.startsWith('10.') && 
										!ip.startsWith('169.254.') &&
										!ip.match(/^172\.(1[6-9]|2[0-9]|3[01])\./)) {
										detectedIPs.add(ip);
									}
								}
							}
						};

						pc.onicegatheringstatechange = function() {
							if (pc.iceGatheringState === 'complete') {
								cleanup();
								// Multiple public IPs often indicate VPN
								const confidence = detectedIPs.size > 1 ? 0.7 : (detectedIPs.size === 1 ? 0.3 : 0);
								resolve({ 
									detected: detectedIPs.size > 1, 
									confidence: confidence,
									ips: Array.from(detectedIPs)
								});
							}
						};

						// Create data channel and offer
						pc.createDataChannel('vpn-test');
						pc.createOffer()
							.then(offer => pc.setLocalDescription(offer))
							.catch(() => {
								cleanup();
								resolve({ detected: false, confidence: 0 });
							});

					} catch (error) {
						resolve({ detected: false, confidence: 0 });
					}
				});
			}

			// Enhanced timezone detection
			function detectTimezoneAnomaly() {
				try {
					const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
					const offset = new Date().getTimezoneOffset();
					const languages = navigator.languages || [navigator.language];
					
					// Common timezone-language mismatches
					const suspicious = [
						// US timezone with non-US language as primary
						{ tz: /America\/(New_York|Chicago|Denver|Los_Angeles)/, lang: /^(?!en-US)/ },
						// EU timezone with non-EU language
						{ tz: /Europe\//, lang: /^(zh|ja|ko|ar|hi)/ },
						// Asian timezone with western language
						{ tz: /Asia\//, lang: /^(en-US|en-GB|fr|de|es)/ }
					];

					const isMatch = suspicious.some(rule => 
						rule.tz.test(timezone) && rule.lang.test(languages[0])
					);

					// Also check if timezone offset doesn't match expected for the timezone
					const expectedOffsets = {
						'America/New_York': -300,
						'Europe/London': 0,
						'Asia/Tokyo': -540
					};
					
					const expectedOffset = expectedOffsets[timezone];
					const offsetMismatch = expectedOffset && Math.abs(offset - expectedOffset) > 60;

					return {
						detected: isMatch || offsetMismatch,
						confidence: (isMatch ? 0.6 : 0) + (offsetMismatch ? 0.4 : 0),
						details: { timezone, offset, languages: languages[0] }
					};
				} catch (error) {
					return { detected: false, confidence: 0 };
				}
			}

			// DNS-based detection
			async function detectDNSLeak() {
				try {
					const controller = new AbortController();
					const timeout = setTimeout(() => controller.abort(), 6000);
					
					// Test multiple endpoints
					const tests = [
						'https://1.1.1.1/cdn-cgi/trace',
						'https://ipinfo.io/json',
						'https://api.ipify.org?format=json'
					];

					const promises = tests.map(async (url) => {
						try {
							const response = await fetch(url, { 
								signal: controller.signal,
								mode: 'cors',
								cache: 'no-cache'
							});
							if (response.ok) {
								return await response.text();
							}
						} catch (e) {
							return null;
						}
					});

					const results = await Promise.allSettled(promises);
					clearTimeout(timeout);

					const validResults = results
						.filter(r => r.status === 'fulfilled' && r.value)
						.map(r => r.value);

					// Look for VPN indicators in responses
					const vpnIndicators = validResults.some(result => 
						result.includes('vpn=true') || 
						result.includes('proxy') ||
						result.includes('hosting') ||
						/datacenter|server|cloud/i.test(result)
					);

					return {
						detected: vpnIndicators,
						confidence: vpnIndicators ? 0.8 : 0.1,
						results: validResults.length
					};

				} catch (error) {
					return { detected: false, confidence: 0 };
				}
			}

			// Header-based detection
			function detectSuspiciousHeaders() {
				try {
					// Check for common VPN/proxy headers (client-side detection limited)
					const userAgent = navigator.userAgent;
					const platform = navigator.platform;
					
					// Suspicious patterns
					const suspicious = [
						/headless/i.test(userAgent),
						/phantom/i.test(userAgent),
						platform === 'Linux' && /Windows/i.test(userAgent),
						navigator.webdriver === true
					];

					const detectedCount = suspicious.filter(Boolean).length;
					
					return {
						detected: detectedCount > 1,
						confidence: detectedCount * 0.3,
						patterns: detectedCount
					};

				} catch (error) {
					return { detected: false, confidence: 0 };
				}
			}

			// Canvas fingerprinting for consistency check
			function detectFingerprintInconsistency() {
				try {
					const canvas = document.createElement('canvas');
					const ctx = canvas.getContext('2d');
					ctx.textBaseline = 'top';
					ctx.font = '14px Arial';
					ctx.fillText('VPN Detection Test 🔒🌍', 2, 2);
					
					const currentFingerprint = canvas.toDataURL();
					const storedFingerprint = localStorage.getItem('_canvas_fp');
					
					if (storedFingerprint) {
						const changed = storedFingerprint !== currentFingerprint;
						if (!changed) {
							localStorage.setItem('_canvas_fp', currentFingerprint);
						}
						return {
							detected: changed,
							confidence: changed ? 0.5 : 0,
							changed: changed
						};
					} else {
						localStorage.setItem('_canvas_fp', currentFingerprint);
						return { detected: false, confidence: 0 };
					}
				} catch (error) {
					return { detected: false, confidence: 0 };
				}
			}

			// Enhanced API-based detection
			async function detectViaAPIs() {
				const apis = [
					{
						url: 'https://ipapi.co/json/',
						parser: (data) => ({
							detected: data.org && /vpn|proxy|hosting|datacenter/i.test(data.org),
							confidence: 0.7,
							info: data.org
						})
					},
					{
						url: 'https://ipinfo.io/json',
						parser: (data) => ({
							detected: data.org && /hosting|cloud|datacenter|vpn/i.test(data.org),
							confidence: 0.6,
							info: data.org
						})
					}
				];

				const results = await Promise.allSettled(
					apis.map(async (api) => {
						try {
							const controller = new AbortController();
							const timeout = setTimeout(() => controller.abort(), 8000);
							
							const response = await fetch(api.url, {
								signal: controller.signal,
								mode: 'cors',
								cache: 'no-cache'
							});
							
							clearTimeout(timeout);
							
							if (response.ok) {
								const data = await response.json();
								return api.parser(data);
							}
						} catch (e) {
							return { detected: false, confidence: 0 };
						}
					})
				);

				const validResults = results
					.filter(r => r.status === 'fulfilled')
					.map(r => r.value);

				const detections = validResults.filter(r => r.detected);
				const avgConfidence = detections.length > 0 ? 
					detections.reduce((sum, r) => sum + r.confidence, 0) / detections.length : 0;

				return {
					detected: detections.length > 0,
					confidence: avgConfidence,
					sources: detections.length,
					details: detections.map(d => d.info).filter(Boolean)
				};
			}

			// Main detection orchestrator
			async function runVPNDetection() {
				try {
					console.log('Starting VPN detection...');
					
					const detectionPromises = [
						detectWebRTCLeak(),
						Promise.resolve(detectTimezoneAnomaly()),
						detectDNSLeak(),
						Promise.resolve(detectSuspiciousHeaders()),
						Promise.resolve(detectFingerprintInconsistency()),
						detectViaAPIs()
					];

					const timeoutPromise = new Promise((_, reject) => {
						setTimeout(() => reject(new Error('Detection timeout')), VPN_CONFIG.timeout);
					});

					const results = await Promise.race([
						Promise.allSettled(detectionPromises),
						timeoutPromise
					]);

					if (results instanceof Error) {
						console.log('VPN detection timed out');
						return;
					}

					// Process results
					const validResults = results
						.filter(r => r.status === 'fulfilled')
						.map(r => r.value);

					let totalScore = 0;
					let detectionCount = 0;

					validResults.forEach((result, index) => {
						const methodName = VPN_CONFIG.detectionMethods[index];
						detectionState.results[methodName] = result;
						
						if (result.detected) {
							totalScore += result.confidence || 0.5;
							detectionCount++;
						}
					});

					detectionState.score = validResults.length > 0 ? totalScore / validResults.length : 0;
					detectionState.detections = detectionCount;

					console.log('VPN Detection Results:', {
						score: detectionState.score.toFixed(2),
						detections: detectionState.detections,
						threshold: VPN_CONFIG.thresholds.minScore,
						details: detectionState.results
					});

					// Trigger block if thresholds exceeded
					if (detectionState.score >= VPN_CONFIG.thresholds.minScore || 
						detectionState.detections >= VPN_CONFIG.thresholds.minDetections) {
						blockAccess();
					}

				} catch (error) {
					console.error('VPN detection error:', error);
				}
			}

			// Block access function
			function blockAccess() {
				if (detectionState.blocked) return;
				
				detectionState.blocked = true;
				console.log('Access blocked due to VPN/Proxy detection');
				
				const blockElement = document.getElementById('vpnBlock');
				if (blockElement) {
					blockElement.style.display = 'flex';
					document.body.style.overflow = 'hidden';
				}
			}

			// Initialize detection
			function initializeDetection() {
				if (document.readyState === 'loading') {
					document.addEventListener('DOMContentLoaded', runVPNDetection);
				} else {
					setTimeout(runVPNDetection, 500);
				}
			}

			// Start detection
			initializeDetection();

		})();

		/* App logic */
		let currentFilter = 'all';
		function performSearch() {
			const q = document.getElementById('mainSearch').value.trim();
			if (!q) { alert('Please enter a search term to continue'); return; }
			alert(`Searching for "${q}"...`);
		}
		function openContentLocker(name) {
			const popup = document.getElementById('contentLockerPopup');
			const iframe = document.getElementById('contentLockerFrame');
			iframe.src = 'https://installchecker.com/cl/i/o6wn2d';
			popup.classList.add('show');
			document.body.style.overflow = 'hidden';
			console.log('Opening content locker for', name || 'item');
		}
		function closeContentLocker() {
			const popup = document.getElementById('contentLockerPopup');
			const iframe = document.getElementById('contentLockerFrame');
			popup.classList.remove('show'); iframe.src=''; document.body.style.overflow='auto';
		}
		document.getElementById('contentLockerPopup').addEventListener('click', function(e) { if (e.target === this) closeContentLocker(); });
		document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeContentLocker(); });
		function showInfo(type) { alert('Opening ' + type + ' information...'); }
		document.getElementById('mainSearch').addEventListener('keypress', function(e) { if (e.key === 'Enter') performSearch(); });

		/* Fill grid with empty cards */
		(function populateGrid() {
			const grid = document.getElementById('grid');
			const categories = ['action','adventure','racing','strategy','casual','sports','puzzle'];
			const total = 18;
			const frag = document.createDocumentFragment();
			
			// Steam game image for one of the cards
			const steamGameImage = 'https://shared.steamstatic.com/store_item_assets/steam/apps/2059310/capsule_616x353.jpg';
			
			for (let i = 0; i < total; i++) {
				const cat = categories[i % categories.length];
				const isNew = i % 7 === 0 ? '1' : '0';
				const isUpdated = i % 5 === 0 ? '1' : '0';
				const card = document.createElement('div'); 
				card.className='card';
				card.setAttribute('data-category', cat); 
				card.setAttribute('data-new', isNew); 
				card.setAttribute('data-updated', isUpdated);
				card.title='Tap to open';
				
				const poster = document.createElement('div'); 
				poster.className='poster';
				
				// Add the Steam game image to the 5th card (index 4)
				if (i === 4) {
					poster.style.backgroundImage = `url(${steamGameImage})`;
				}
				
				const overlay = document.createElement('div'); 
				overlay.className='overlay'; 
				poster.appendChild(overlay);
				
				const badge = document.createElement('div'); 
				badge.className='badge';
				badge.textContent = isNew==='1' ? 'NEW' : (isUpdated==='1' ? 'UPDATED' : '');
				if (badge.textContent) badge.style.opacity='1';
				poster.appendChild(badge);
				
				const meta = document.createElement('div'); 
				meta.className='meta';
				const title = document.createElement('div'); 
				title.className='title'; 
				// Add title for the Steam game
				title.textContent = i === 4 ? 'Halo Infinite' : '';
				meta.appendChild(title);
				
				card.appendChild(poster); 
				card.appendChild(meta);
				card.addEventListener('click', () => openContentLocker('Item'));
				frag.appendChild(card);
			}
			grid.appendChild(frag);
		})();

		/* Hero slider */
		(function setupSlider(){
			const slidesEl = document.getElementById('slides');
			const slides = Array.from(slidesEl.children);
			const dotsEl = document.getElementById('dots');
			const prev = document.getElementById('prev');
			const next = document.getElementById('next');
			let index = 0, autoTimer = null, delay = 4500;

			slides.forEach((_, i) => {
				const d = document.createElement('div');
				d.className = 'dot' + (i===0 ? ' active' : '');
				d.addEventListener('click', () => goTo(i));
				dotsEl.appendChild(d);
			});
			function update(){
				slidesEl.style.transform = `translateX(-${index*100}%)`;
				dotsEl.querySelectorAll('.dot').forEach((d,i)=>d.classList.toggle('active', i===index));
				lazy(index);
			}
			function goTo(i){ index = (i + slides.length) % slides.length; update(); restart(); }
			function nextSlide(){ goTo(index+1) }
			function prevSlide(){ goTo(index-1) }
			function start(){ autoTimer = setInterval(nextSlide, delay) }
			function stop(){ clearInterval(autoTimer) }
			function restart(){ stop(); start() }
			function lazy(i){
				const s = slides[i];
				const url = s.getAttribute('data-bg');
				if (url && !s.style.backgroundImage){ s.style.backgroundImage = `url('${url}')`; }
			}
			lazy(0);
			next.addEventListener('click', nextSlide);
			prev.addEventListener('click', prevSlide);
			let startX = 0, dx = 0, isDown = false;
			slidesEl.addEventListener('pointerdown', (e)=>{ isDown=true; startX=e.clientX; dx=0; stop(); slidesEl.setPointerCapture(e.pointerId); });
			slidesEl.addEventListener('pointermove', (e)=>{ if(!isDown) return; dx=e.clientX-startX; slidesEl.style.transform=`translateX(calc(-${index*100}% + ${dx}px))`; });
			slidesEl.addEventListener('pointerup', (e)=>{ if(!isDown) return; isDown=false; slidesEl.releasePointerCapture(e.pointerId); if (Math.abs(dx) > 60){ dx<0 ? nextSlide() : prevSlide(); } else { update(); start(); } });
			slidesEl.addEventListener('pointercancel', ()=>{ isDown=false; update(); start(); });
			slidesEl.addEventListener('mouseenter', stop);
			slidesEl.addEventListener('mouseleave', start);
			start();
			window.addEventListener('visibilitychange', ()=>{ document.hidden ? stop() : start(); });
		})();
	</script>
</body>
</html>
