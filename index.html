<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced VPN Detection Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .status {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .status h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .progress {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .results {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .score {
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
        }
        
        .score.low { background: #4CAF50; }
        .score.medium { background: #FF9800; }
        .score.high { background: #f44336; }
        
        .final-result {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .final-result.safe {
            background: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #4caf50;
        }
        
        .final-result.suspicious {
            background: #fff3e0;
            color: #f57c00;
            border: 2px solid #ff9800;
        }
        
        .final-result.blocked {
            background: #ffebee;
            color: #c62828;
            border: 2px solid #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="status">
            <h1>üîç Enhanced VPN Detection</h1>
            <p id="statusText">Initializing security checks...</p>
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
        
        <div class="results" id="results" style="display: none;">
            <h3>Detection Results</h3>
            <div id="resultsList"></div>
            <div id="finalResult"></div>
        </div>
    </div>

    <script>
        (function() {
            'use strict';
            
            // Enhanced VPN Detection System
            class VPNDetector {
                constructor() {
                    this.score = 0;
                    this.maxScore = 100;
                    this.results = [];
                    this.isBlocked = false;
                    this.config = {
                        blockThreshold: 65,
                        suspiciousThreshold: 40,
                        timeoutMs: 8000,
                        enableLogging: true
                    };
                }
                
                log(message, data = null) {
                    if (this.config.enableLogging) {
                        console.log(`[VPN Detector] ${message}`, data || '');
                    }
                }
                
                addScore(points, method, details = '') {
                    this.score += points;
                    this.results.push({
                        method,
                        points,
                        details,
                        timestamp: Date.now()
                    });
                    this.log(`+${points} for ${method}. Total: ${this.score}`, details);
                }
                
                updateProgress(percentage, text) {
                    document.getElementById('progressBar').style.width = `${percentage}%`;
                    document.getElementById('statusText').textContent = text;
                }
                
                // Method 1: Fast WebRTC IP Detection (Optimized)
                async checkWebRTC() {
                    return new Promise((resolve) => {
                        const timeout = setTimeout(() => {
                            this.addScore(20, 'WebRTC Timeout', 'WebRTC failed to respond');
                            resolve();
                        }, 2000);
                        
                        try {
                            const pc = new (window.RTCPeerConnection || window.webkitRTCPeerConnection)({
                                iceServers: [
                                    { urls: 'stun:stun.l.google.com:19302' },
                                    { urls: 'stun:stun1.l.google.com:19302' }
                                ]
                            });
                            
                            const ips = new Set();
                            let candidateCount = 0;
                            
                            pc.onicecandidate = (event) => {
                                if (!event.candidate) return;
                                
                                candidateCount++;
                                const match = event.candidate.candidate.match(/([0-9]{1,3}\.){3}[0-9]{1,3}/);
                                if (match) {
                                    ips.add(match[0]);
                                }
                                
                                // Quick analysis after collecting some candidates
                                if (candidateCount >= 5) {
                                    this.analyzeWebRTCResults(ips, candidateCount);
                                    clearTimeout(timeout);
                                    pc.close();
                                    resolve();
                                }
                            };
                            
                            pc.createDataChannel('test');
                            pc.createOffer().then(offer => pc.setLocalDescription(offer));
                            
                        } catch (error) {
                            this.addScore(25, 'WebRTC Error', error.message);
                            clearTimeout(timeout);
                            resolve();
                        }
                    });
                }
                
                analyzeWebRTCResults(ips, candidateCount) {
                    const ipArray = Array.from(ips);
                    const publicIPs = ipArray.filter(ip => this.isPublicIP(ip));
                    const privateIPs = ipArray.filter(ip => this.isPrivateIP(ip));
                    
                    if (publicIPs.length > 1) {
                        this.addScore(35, 'Multiple Public IPs', `Found ${publicIPs.length} public IPs`);
                    }
                    
                    if (candidateCount > 10) {
                        this.addScore(15, 'Excessive ICE Candidates', `${candidateCount} candidates`);
                    }
                    
                    if (ipArray.length === 0) {
                        this.addScore(30, 'No WebRTC IPs', 'WebRTC completely blocked');
                    }
                    
                    // Check for VPN IP patterns
                    publicIPs.forEach(ip => {
                        if (this.isVPNPattern(ip)) {
                            this.addScore(25, 'VPN IP Pattern', ip);
                        }
                    });
                }
                
                isPublicIP(ip) {
                    return !this.isPrivateIP(ip) && ip !== '127.0.0.1' && !ip.startsWith('169.254.');
                }
                
                isPrivateIP(ip) {
                    return ip.startsWith('192.168.') || ip.startsWith('10.') || 
                           (ip.startsWith('172.') && parseInt(ip.split('.')[1]) >= 16 && parseInt(ip.split('.')[1]) <= 31);
                }
                
                isVPNPattern(ip) {
                    // Common VPN IP ranges and patterns
                    const vpnPatterns = [
                        /^185\./, /^194\./, /^91\./, /^37\./, /^46\./,  // European VPN ranges
                        /^103\./, /^45\./, /^104\./, /^199\./,          // US VPN ranges
                        /^5\./, /^31\./, /^89\./                       // Other common VPN ranges
                    ];
                    return vpnPatterns.some(pattern => pattern.test(ip));
                }
                
                // Method 2: Fast Geolocation Check
                async checkGeolocation() {
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 3000);
                        
                        const response = await fetch('https://ipapi.co/json/', {
                            signal: controller.signal,
                            headers: { 'User-Agent': 'Mozilla/5.0 (compatible; Security-Check/1.0)' }
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (!response.ok) throw new Error('API failed');
                        
                        const data = await response.json();
                        this.analyzeGeolocation(data);
                        
                    } catch (error) {
                        this.addScore(20, 'Geo API Blocked', error.message);
                    }
                }
                
                analyzeGeolocation(data) {
                    // VPN hosting countries
                    const vpnCountries = new Set(['NL', 'CH', 'PA', 'VG', 'SC', 'SG', 'BZ', 'KY', 'LU', 'MT']);
                    
                    if (vpnCountries.has(data.country_code)) {
                        this.addScore(25, 'VPN Country', `${data.country_code} - ${data.country_name}`);
                    }
                    
                    // Check for hosting/datacenter
                    const org = (data.org || '').toLowerCase();
                    const hostingKeywords = ['hosting', 'datacenter', 'server', 'cloud', 'digital ocean', 'linode', 'vultr', 'hetzner'];
                    
                    if (hostingKeywords.some(keyword => org.includes(keyword))) {
                        this.addScore(30, 'Datacenter IP', data.org);
                    }
                    
                    // Timezone mismatch
                    try {
                        const userTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
                        const expectedTz = data.timezone;
                        if (expectedTz && userTz !== expectedTz) {
                            this.addScore(15, 'Timezone Mismatch', `User: ${userTz}, Expected: ${expectedTz}`);
                        }
                    } catch (e) {
                        this.addScore(10, 'Timezone Error', 'Cannot read timezone');
                    }
                }
                
                // Method 3: Enhanced Browser Fingerprinting
                checkBrowserFingerprint() {
                    // Automation detection
                    if (navigator.webdriver) {
                        this.addScore(40, 'Webdriver Detected', 'Automated browser');
                    }
                    
                    // Headless browser detection
                    if (window.outerHeight === 0 || window.outerWidth === 0) {
                        this.addScore(35, 'Headless Browser', 'Zero outer dimensions');
                    }
                    
                    // Missing expected properties
                    const expectedProps = ['chrome', 'permissions', 'mediaDevices', 'serviceWorker'];
                    const missingProps = expectedProps.filter(prop => !(prop in navigator));
                    
                    if (missingProps.length > 1) {
                        this.addScore(20, 'Missing Browser Features', missingProps.join(', '));
                    }
                    
                    // Plugin analysis
                    if (navigator.plugins.length === 0 && !(/Mobile|Android|iPhone|iPad/.test(navigator.userAgent))) {
                        this.addScore(15, 'No Plugins', 'Desktop browser with no plugins');
                    }
                    
                    // Screen resolution patterns
                    const suspiciousResolutions = ['1024x768', '800x600', '1280x1024'];
                    const currentRes = `${screen.width}x${screen.height}`;
                    
                    if (suspiciousResolutions.includes(currentRes)) {
                        this.addScore(15, 'Bot Resolution', currentRes);
                    }
                    
                    // Language inconsistencies
                    const languages = navigator.languages || [navigator.language];
                    if (languages.length === 1 && languages[0] === 'en-US') {
                        this.addScore(10, 'Single Language', 'Only en-US detected');
                    }
                }
                
                // Method 4: Performance Timing Analysis
                checkPerformanceTiming() {
                    try {
                        const timing = performance.timing;
                        const navigation = performance.navigation;
                        
                        // Suspiciously fast loading times
                        const loadTime = timing.loadEventEnd - timing.navigationStart;
                        if (loadTime < 100) {
                            this.addScore(20, 'Too Fast Loading', `${loadTime}ms`);
                        }
                        
                        // Check if timing values are missing or zero
                        const criticalTimings = [timing.domainLookupStart, timing.connectStart, timing.responseStart];
                        if (criticalTimings.some(time => time === 0)) {
                            this.addScore(15, 'Missing Timing Data', 'Performance timing incomplete');
                        }
                        
                    } catch (error) {
                        this.addScore(10, 'Performance API Error', error.message);
                    }
                }
                
                // Method 5: Canvas and Hardware Fingerprinting
                checkCanvasFingerprint() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Enhanced canvas test
                        ctx.textBaseline = 'alphabetic';
                        ctx.fillStyle = '#f60';
                        ctx.fillRect(125, 1, 62, 20);
                        ctx.fillStyle = '#069';
                        ctx.font = '11pt Arial';
                        ctx.fillText('VPN Detection üîç', 2, 15);
                        ctx.fillStyle = 'rgba(102, 204, 0, 0.2)';
                        ctx.font = '18pt Arial';
                        ctx.fillText('VPN Detection üîç', 4, 45);
                        
                        const canvasData = canvas.toDataURL();
                        
                        // Check for blocked canvas
                        if (canvasData.length < 100 || canvasData === 'data:,') {
                            this.addScore(25, 'Canvas Blocked', 'Canvas rendering prevented');
                        }
                        
                        // Check for common bot signatures
                        const hash = this.simpleHash(canvasData);
                        const commonBotHashes = [0, 1, 2147483647]; // Common empty/default hashes
                        
                        if (commonBotHashes.includes(hash)) {
                            this.addScore(20, 'Bot Canvas Signature', `Hash: ${hash}`);
                        }
                        
                    } catch (error) {
                        this.addScore(25, 'Canvas Error', error.message);
                    }
                }
                
                simpleHash(str) {
                    let hash = 0;
                    for (let i = 0; i < str.length; i++) {
                        const char = str.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; // Convert to 32-bit integer
                    }
                    return Math.abs(hash);
                }
                
                // Method 6: Network Latency Test
                async checkNetworkLatency() {
                    const testUrls = [
                        'https://www.google.com/favicon.ico',
                        'https://www.cloudflare.com/favicon.ico'
                    ];
                    
                    let totalLatency = 0;
                    let tests = 0;
                    
                    for (const url of testUrls) {
                        try {
                            const start = performance.now();
                            await fetch(url, { 
                                mode: 'no-cors', 
                                cache: 'no-cache',
                                signal: AbortSignal.timeout(2000)
                            });
                            const latency = performance.now() - start;
                            totalLatency += latency;
                            tests++;
                        } catch (error) {
                            // Network blocked or slow
                            this.addScore(15, 'Network Test Failed', url);
                        }
                    }
                    
                    if (tests > 0) {
                        const avgLatency = totalLatency / tests;
                        if (avgLatency > 1000) {
                            this.addScore(20, 'High Latency', `${avgLatency.toFixed(0)}ms average`);
                        }
                    } else {
                        this.addScore(30, 'All Network Tests Failed', 'Complete network blocking');
                    }
                }
                
                // Method 7: Behavioral Analysis (Quick)
                async checkBehavior() {
                    return new Promise((resolve) => {
                        let mouseEvents = 0;
                        let keyEvents = 0;
                        
                        const mouseHandler = () => mouseEvents++;
                        const keyHandler = () => keyEvents++;
                        
                        document.addEventListener('mousemove', mouseHandler);
                        document.addEventListener('keydown', keyHandler);
                        
                        setTimeout(() => {
                            document.removeEventListener('mousemove', mouseHandler);
                            document.removeEventListener('keydown', keyHandler);
                            
                            if (mouseEvents === 0 && keyEvents === 0) {
                                this.addScore(25, 'No Human Interaction', 'No mouse/keyboard activity');
                            }
                            
                            resolve();
                        }, 1500); // Reduced from 4 seconds
                    });
                }
                
                // Main detection orchestrator
                async runDetection() {
                    this.log('Starting enhanced VPN detection...');
                    
                    try {
                        // Phase 1: Instant checks (0-20%)
                        this.updateProgress(10, 'Checking browser fingerprint...');
                        this.checkBrowserFingerprint();
                        
                        this.updateProgress(15, 'Analyzing performance metrics...');
                        this.checkPerformanceTiming();
                        
                        this.updateProgress(20, 'Testing canvas fingerprint...');
                        this.checkCanvasFingerprint();
                        
                        // Phase 2: Network checks (20-70%)
                        this.updateProgress(30, 'Checking WebRTC...');
                        await this.checkWebRTC();
                        
                        this.updateProgress(50, 'Verifying geolocation...');
                        await this.checkGeolocation();
                        
                        this.updateProgress(70, 'Testing network latency...');
                        await this.checkNetworkLatency();
                        
                        // Phase 3: Behavioral analysis (70-100%)
                        this.updateProgress(85, 'Analyzing user behavior...');
                        await this.checkBehavior();
                        
                        this.updateProgress(100, 'Analysis complete!');
                        
                        // Display results
                        this.displayResults();
                        
                    } catch (error) {
                        this.log('Detection error:', error);
                        this.addScore(20, 'System Error', error.message);
                        this.displayResults();
                    }
                }
                
                displayResults() {
                    const resultsDiv = document.getElementById('results');
                    const resultsList = document.getElementById('resultsList');
                    const finalResult = document.getElementById('finalResult');
                    
                    // Show results
                    resultsDiv.style.display = 'block';
                    
                    // Display individual results
                    resultsList.innerHTML = this.results.map(result => {
                        const scoreClass = result.points >= 25 ? 'high' : result.points >= 15 ? 'medium' : 'low';
                        return `
                            <div class="result-item">
                                <span>${result.method}${result.details ? `: ${result.details}` : ''}</span>
                                <span class="score ${scoreClass}">+${result.points}</span>
                            </div>
                        `;
                    }).join('');
                    
                    // Calculate final assessment
                    const percentage = Math.min((this.score / this.maxScore) * 100, 100);
                    let status, className, action;
                    
                    if (this.score >= this.config.blockThreshold) {
                        status = 'üö´ VPN/Proxy Detected - Access Blocked';
                        className = 'blocked';
                        action = 'High risk detected. Please disable VPN/proxy and try again.';
                        this.isBlocked = true;
                    } else if (this.score >= this.config.suspiciousThreshold) {
                        status = '‚ö†Ô∏è Suspicious Activity Detected';
                        className = 'suspicious';
                        action = 'Some unusual patterns detected. Please verify you are not using a VPN.';
                    } else {
                        status = '‚úÖ User Verified - Access Granted';
                        className = 'safe';
                        action = 'All security checks passed successfully.';
                    }
                    
                    finalResult.innerHTML = `
                        <div class="final-result ${className}">
                            <div style="font-size: 24px; margin-bottom: 10px;">${status}</div>
                            <div style="font-size: 16px; margin-bottom: 10px;">
                                Detection Score: ${this.score}/${this.maxScore} (${percentage.toFixed(1)}%)
                            </div>
                            <div style="font-size: 14px; font-weight: normal;">${action}</div>
                        </div>
                    `;
                    
                    // Log final result
                    this.log(`Detection completed. Score: ${this.score}/${this.maxScore} (${percentage.toFixed(1)}%)`);
                    this.log(`Status: ${className.toUpperCase()}`);
                    
                    // If blocked, could redirect or hide content here
                    if (this.isBlocked) {
                        this.handleBlocking();
                    }
                }
                
                handleBlocking() {
                    // In a real implementation, you might:
                    // 1. Redirect to a blocked page
                    // 2. Hide main content
                    // 3. Show alternative content
                    // 4. Log the detection
                    
                    this.log('User blocked due to VPN/proxy detection');
                    
                    // Example: Could replace page content
                    // document.body.innerHTML = this.getBlockedPageHTML();
                }
                
                getBlockedPageHTML() {
                    return `
                        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-family: -apple-system, BlinkMacSystemFont, sans-serif;">
                            <div style="background: rgba(255,255,255,0.95); padding: 40px; border-radius: 20px; text-align: center; max-width: 500px;">
                                <div style="font-size: 60px; margin-bottom: 20px;">üö´</div>
                                <h2>Access Restricted</h2>
                                <p>VPN or proxy detected. Please disable it and try again.</p>
                                <button onclick="window.location.reload()" style="background: #007bff; color: white; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer;">Try Again</button>
                            </div>
                        </div>
                    `;
                }
            }
            
            // Initialize and run detection
            const detector = new VPNDetector();
            
            // Start detection when page loads
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => detector.runDetection());
            } else {
                detector.runDetection();
            }
            
        })();
    </script>
</body>
</html>
